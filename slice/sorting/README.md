[toc]

# 排序算法

## 冒泡排序

### 思路
设置一标志性变量pos,用于记录每趟排序中最后一次进行交换的位置。由于pos位置之后的记录均已交换到位,故在进行下一趟排序时只要扫描到pos位置即可
### 代码
[代码实现](./bubbleSort/main.go)
### 复杂度
复杂度：T(n) = O(n2)

## 插入排序

### 思路

- 从第一个元素开始，该元素可以认为已经被排序；
- 取出下一个元素，在已经排序的元素序列中从后向前扫描；
- 如果该元素（已排序）大于新元素，将该元素移到下一位置；
- 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；
- 将新元素插入到该位置后；
- 重复步骤2~5。

### 代码
[代码实现](./insertSort/main.go)

### 复杂度
复杂度：T(n) = O(n2)

## 快速排序

### 思路
- 选择中间值作为基准值
- 创建左右指针，左指针（初始值为0）中大于基准值的与右指针（初始值为数组最右边下标）中小于基准值的交换，以达到基准值左边都小于基准值，基准值右边都大于基准值
- 将数组不停地划分为小数组，重复以上步骤

### 代码
[代码实现](./quickSort/main.go)

### 复杂度
复杂度：O(nlogn)

## 归并排序

### 思路
- 将原始数组切分成小数组，直至小数组长度为1
- 将小数组比较之后再合并为一个大的数组

### 代码
[代码实现](./mergeSort/main.go)

### 复杂度

复杂度：O(nlongn)

## 选择排序
### 思路

遍历数组， 从中选择最小元素，将它与数组的第一个元素交换位置。继续从数组剩下的元素中选择出最小的元素，将它与数组的第二个元素交换位置。循环以上过程，直到将整个数组排序。

### 代码
[代码实现](./selectionSort/main.go)

### 复杂度
时间复杂度分析：$O(N^{2})$。选择排序大约需要 $N^{2}/2$ 次比较和 $N$ 次交换，它的运行时间与输入无关，这个特点使得它对一个已经排序的数组也需要很多的比较和交换操作。